grammar Java;

// Tokens
CLASS: 'class';
PUBLIC: 'public';
STATIC: 'static';
VOID: 'void';
MAIN: 'main';
STRING: 'String';
EXTENDS: 'extends';
IF: 'if';
ELSE: 'else';
WHILE: 'while';
FOR: 'for';
RETURN: 'return';
INT: 'int';
BOOLEAN: 'boolean';
TRUE: 'true';
FALSE: 'false';
THIS: 'this';
NEW: 'new';
ID: [a-zA-Z]+;
LPAREN: '(';
RPAREN: ')';
LBRACE: '{';
RBRACE: '}';
LBRACKET: '[';
RBRACKET: ']';
SEMI: ';';
COMMA: ',';
EQ: '=';
NEQ: '!=';
LTE: '<=';
GTE: '>=';
LT: '<';
GT: '>';
PLUS: '+';
MINUS: '-';
MULT: '*';
DIV: '/';
AND: '&&';
OR: '||';
NOT: '!';
INTEGER: [0-9]+;
WS: [ \t\r\n]+ -> skip;

// Rules
program : classDeclaration* mainMethod;
classDeclaration : CLASS ID (EXTENDS ID)? LBRACE (fieldDeclaration | methodDeclaration)* RBRACE;
mainMethod : PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN LBRACE statement* RBRACE;
fieldDeclaration : (PUBLIC | STATIC)? (INT | BOOLEAN | ID) ID SEMI;
methodDeclaration : (PUBLIC | STATIC)? (INT | VOID | BOOLEAN | ID) ID LPAREN parameterList? RPAREN LBRACE statement* RBRACE;
parameterList : type ID (COMMA type ID)*;
type : INT | BOOLEAN | ID;
statement : block | ifStatement | whileStatement | forStatement | returnStatement | expressionStatement;
block : LBRACE statement* RBRACE;
ifStatement : IF LPAREN expression RPAREN statement (ELSE statement)?;
whileStatement : WHILE LPAREN expression RPAREN statement;
forStatement : FOR LPAREN expression SEMI expression SEMI expression RPAREN statement;
returnStatement : RETURN expression? SEMI;
expressionStatement : expression SEMI;
expression : assignmentExpression;
assignmentExpression : conditionalExpression (EQ assignmentExpression)?;
conditionalExpression : conditionalOrExpression (OR conditionalExpression)?;
conditionalOrExpression : conditionalAndExpression (AND conditionalOrExpression)?;
conditionalAndExpression : equalityExpression (EQ equalityExpression)?;
equalityExpression : relationalExpression ((EQ | NEQ) relationalExpression)?;
relationalExpression : additiveExpression ((LT | GT | LTE | GTE) additiveExpression)?;
additiveExpression : multiplicativeExpression ((PLUS | MINUS) multiplicativeExpression)?;
multiplicativeExpression : unaryExpression ((MULT | DIV) unaryExpression)?;
unaryExpression : (PLUS | MINUS | NOT)? primaryExpression;
primaryExpression : ID | INTEGER | TRUE | FALSE | THIS | NEW ID | LPAREN expression RPAREN;
